/**
 *  This test ensures that the sketch application (for mixed: internal ->
 *  Elemental matrices) is done correctly (on-the-fly matrix multiplication in
 *  the code is compared to true matrix multiplication).
 *  This test builds on the following assumptions:
 *
 *      - Elemental GEMM returns the correct result, and
 *      - the random numbers in row_idx and row_value (see
 *        hash_transform_data_t) are drawn from the promised distributions.
 */


#include <vector>

#include <boost/mpi.hpp>
#include <boost/test/minimal.hpp>

#include <skylark.hpp>

#define SKYLARK_NO_ANY

#include "test_utils.hpp"

typedef skylark::base::sparse_matrix_t<double> LocalMatrixType;

typedef El::DistMatrix<double, El::VC, El::STAR> dense_vc_star_matrix_t;
typedef skylark::base::sparse_vc_star_matrix_t<double> sparse_vc_star_matrix_t;

template<typename sketch_t, typename dense_matrix_t>
void compute_sketch_matrix(sketch_t sketch, dense_matrix_t &result) {

    std::vector<size_t> row_idx = sketch.getRowIdx();
    std::vector<double> row_val = sketch.getRowValues();

    // PI generated by random number gen
    for(size_t i = 0; i < row_val.size(); ++i) {
        if (result.IsLocal(row_idx[i], i))
            result.Update(row_idx[i], i, row_val[i]);
    }
}

int test_main(int argc, char *argv[]) {

    //////////////////////////////////////////////////////////////////////////
    //[> Parameters <]

    //FIXME: use random sizes?
    const size_t n   = 100;
    const size_t m   = 50;
    const size_t n_s = 60;
    const size_t m_s = 30;

    //////////////////////////////////////////////////////////////////////////
    //[> Setup test <]
    namespace mpi = boost::mpi;

    El::Initialize(argc, argv);

    mpi::environment env(argc, argv);
    mpi::communicator world;
    const size_t rank = world.rank();

    MPI_Comm mpi_world(world);
    El::Grid grid(mpi_world);

    skylark::base::context_t context(0);

    dense_vc_star_matrix_t A_vc(grid);
    El::Uniform(A_vc, n, m);
    El::Zero(A_vc);

    sparse_vc_star_matrix_t A_sparse_vc(n, m, grid);

    double count = 1.0;
    for(int col = 0; col < A_vc.Width(); col++) {
        for(int row = 0; row < A_vc.Height(); row++) {
            A_vc.Update(row, col, count);
            A_sparse_vc.queue_update(row, col, count);
            count++;
        }
    }

    A_sparse_vc.finalize();

    // rowwise application
    //dense_vc_star_matrix_t pi_sketch_r(grid);

    //////////////////////////////////////////////////////////////////////////
    //[> Column wise application DistSparseMatrix -> DistMatrix[VC/*] <]

    typedef El::DistMatrix<double, El::VC, El::STAR> vcs_target_t;

    //[> 1. Create the sketching matrix <]
    test::util::hash_transform_test_t<sparse_vc_star_matrix_t, vcs_target_t>
        SparseVC(n, n_s, context);

    //[> 2. Create space for the sketched matrix <]
    vcs_target_t sketch_A_vcs(n_s, m, grid);
    El::Zero(sketch_A_vcs);

    //[> 3. Apply the transform <]
    SparseVC.apply(A_sparse_vc, sketch_A_vcs,
            skylark::sketch::columnwise_tag());

    //[> 4. Compute expected value using a GEMM <]
    El::DistMatrix<double> Pi_mcmr(n_s, n, grid);
    El::Zero(Pi_mcmr);
    compute_sketch_matrix(SparseVC, Pi_mcmr);

    El::DistMatrix<double> A_mcmr = A_vc;
    El::DistMatrix<double> C(n_s, m, grid);
    El::Gemm(El::NORMAL, El::NORMAL, 1.0, Pi_mcmr, A_mcmr, 0.0, C);

    El::DistMatrix<double, El::STAR, El::STAR> expected_A(n_s, m, grid);
    expected_A = C;
    El::DistMatrix<double, El::STAR, El::STAR> sketched_A(n_s, m, grid);
    sketched_A = sketch_A_vcs;
    check_equal(expected_A, sketched_A);

#if 0
    //////////////////////////////////////////////////////////////////////////
    //[> Row wise application DistSparseMatrix -> DistMatrix[VC/*] <]

    //[> 1. Create the sketching matrix <]
    test::util::hash_transform_test_t<sparse_vc_star_matrix_t, vcs_target_t>
        Sparse_r_vcs(m, m_s, context);

    //[> 2. Create space for the sketched matrix <]
    vcs_target_t sketch_A_r_vcs(n, m_s, grid);
    El::Zero(sketch_A_r_vcs);

    //[> 3. Apply the transform <]
    Sparse_r_vcs.apply(A, sketch_A_r_vcs, skylark::sketch::rowwise_tag());

    //[> 4. Build structure to compare <]
    // easier to check if all processors own result
    result = sketch_A_r_vcs;

    pi_sketch_r.Transpose();
    compute_sketch_matrix(Sparse_r_vcs, A, pi_sketch_r);
    pi_sketch_r.Transpose();
    expected_AR = Mult_AnXBn_Synch<PTDD, double, col_t>(
            A, pi_sketch_r, false, false);
#endif

    return 0;
}
