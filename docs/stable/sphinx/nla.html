<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Numerical Linear Algebra Primitives &mdash; libSkylark  documentation</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="libSkylark  documentation" href="index.html" />
    <link rel="next" title="Machine Learning" href="ml.html" />
    <link rel="prev" title="Sketching Layer" href="sketching.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>libSkylark  documentation</span></a></h1>
        <h2 class="heading"><span>Numerical Linear Algebra Primitives</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="sketching.html">Sketching Layer</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="ml.html">Machine Learning</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="numerical-linear-algebra-primitives">
<h1>Numerical Linear Algebra Primitives<a class="headerlink" href="#numerical-linear-algebra-primitives" title="Permalink to this headline">¶</a></h1>
<p>This layer implements various numerical linear algebra primitives that are
accelerated using sketching.</p>
<div class="section" id="randomized-linear-least-squares">
<span id="simple-linearls"></span><h2>Randomized Linear Least-Squares<a class="headerlink" href="#randomized-linear-least-squares" title="Permalink to this headline">¶</a></h2>
<p>Based on the regression framework in the algorithmic layer, this functionality
provides sketching based linear least-squares regression routines. That is,
solve equations of the form:</p>
<div class="math">
<p><span class="math">\arg\min_X \|A * X - B\|_F</span></p>
</div><p>Note that the various algorithms can be executed directly using the regression API.
This layer just provides an easy-to-use functional interface that mirror Elemental&#8217;s
<a class="reference external" href="http://libelemental.org/documentation/0.83/lapack-like/solve.html">LeastSquares</a>
function, but uses sketching to accelerate the computation.</p>
<p>A running example is provided in <em>libskylark/examples/least_squares.cpp</em>.</p>
<div class="section" id="approximate-least-squares">
<h3>Approximate Least-squares<a class="headerlink" href="#approximate-least-squares" title="Permalink to this headline">¶</a></h3>
<p>Solve the problem approximately using a sktech-and-solve strategy.
Specifically, solve <span class="math">\arg\min_X \|S A X -  S B\|_F</span> where <span class="math">S \in R^{s\times n}</span>
is a Fast Johnson-Lindenstrauss Transform matrix
(<a class="reference external" href="http://www.cs.princeton.edu/~chazelle/pubs/FJLT-sicomp09.pdf">Ailon and Chazelle, 2009</a>).
It can be shown that if <span class="math">s</span> is large enough (as a function of <span class="math">\epsilon</span>), then</p>
<div class="math">
<p><span class="math">\|A * X_{approx} - B\|_F \leq (1+\epsilon) \|A * X - B\|_F</span></p>
</div><p>where <span class="math">X=\arg\min_X \|A * X - B\|_F</span> and <span class="math">X_{approx}</span> is the approximate solution.
For the best known bounds see <a class="reference external" href="http://arxiv.org/abs/1204.0062">Boutsidis and Gittens (2013)</a>.</p>
<dl class="docutils">
<dt>The algorithm used is the one described in:</dt>
<dd><ul class="first last">
<li><div class="first line-block">
<div class="line">P. Drineas, M. W. Mahoney, S. Muthukrishnan, and T. Sarlos</div>
<div class="line"><a class="reference external" href="http://arxiv.org/abs/0710.1435">Faster Least Squares Approximation</a></div>
<div class="line">Numerische Mathematik, 117, 219-249 (2011).</div>
</div>
</li>
</ul>
</dd>
</dl>
<p>Unlike the algorithm described in the paper we allow the user to set the size of <span class="math">s</span>.
There is also a default value, but it is much lower than the one suggested by that paper.</p>
<p>Note: it is assume that a <span class="math">s \times n</span> matrix can fit in the memory of a single node
(<span class="math">n</span> is the number of columns in <span class="math">A</span>).</p>
<hr class="docutils" />
<dl class="function">
<dt id="ApproximateLeastSquares__El::Orientation.El::Matrix:T:CR.El::Matrix:T:CR.El::Matrix:T:R.base::context_tR.i">
void <tt class="descname">ApproximateLeastSquares</tt><big>(</big>El::Orientation <em>orientation</em>, const El::Matrix&lt;T&gt;&amp; <em>A</em>, const El::Matrix&lt;T&gt;&amp; <em>B</em>, El::Matrix&lt;T&gt;&amp; <em>X</em>, base::context_t&amp; <em>context</em>, int <em>sketch_size</em><em>=-1</em><big>)</big><a class="headerlink" href="#ApproximateLeastSquares__El::Orientation.El::Matrix:T:CR.El::Matrix:T:CR.El::Matrix:T:R.base::context_tR.i" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ApproximateLeastSquares__El::Orientation.El::DistMatrix:T.El::VC.El::STAR:CR.El::DistMatrix:T.El::VC.El::STAR:CR.El::DistMatrix:T.El::STAR.El::STAR:R.base::context_tR.i">
void <tt class="descname">ApproximateLeastSquares</tt><big>(</big>El::Orientation <em>orientation</em>, const El::DistMatrix&lt;T, El::VC, El::STAR&gt;&amp; <em>A</em>, const El::DistMatrix&lt;T, El::VC, El::STAR&gt;&amp; <em>B</em>, El::DistMatrix&lt;T, El::STAR, El::STAR&gt;&amp; <em>X</em>, base::context_t&amp; <em>context</em>, int <em>sketch_size</em><em>=-1</em><big>)</big><a class="headerlink" href="#ApproximateLeastSquares__El::Orientation.El::DistMatrix:T.El::VC.El::STAR:CR.El::DistMatrix:T.El::VC.El::STAR:CR.El::DistMatrix:T.El::STAR.El::STAR:R.base::context_tR.i" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>If <cite>orientation</cite> is set to <tt class="docutils literal"><span class="pre">NORMAL</span></tt>, then approximate <span class="math">\arg\min_X \|A * X - B\|_F</span>, otherwise
<cite>orientation</cite> must be equal to <tt class="docutils literal"><span class="pre">ADJOINT</span></tt> and <span class="math">\arg\min_X \|A^H * X - B\|_F</span> is approximated.</p>
<p>sketch_size controls the number of rows in <span class="math">S</span>.</p>
<hr class="docutils" />
<p>A flavor of usage is given in the code snippet below.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;elemental.hpp&gt;</span>
<span class="cp">#include &lt;skylark.hpp&gt;</span>
<span class="p">...</span>
<span class="c1">// Setup regression problem with coefficient matrix A and target matrix B</span>
<span class="p">...</span>

<span class="n">skybase</span><span class="o">::</span><span class="kt">context_t</span> <span class="n">context</span><span class="p">(</span><span class="mi">23234</span><span class="p">);</span>

<span class="c1">// Solve the Least Squres problem of minimizing || AX - B||_2 over X</span>
<span class="n">skylark</span><span class="o">::</span><span class="n">nla</span><span class="o">::</span><span class="n">ApproximateLeastSquares</span><span class="p">(</span><span class="n">El</span><span class="o">::</span><span class="n">NORMAL</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="faster-least-squares">
<h3>Faster Least-squares<a class="headerlink" href="#faster-least-squares" title="Permalink to this headline">¶</a></h3>
<p>Solve the linear least-squares problem using a sketching-accelerated algorithm.
This algorithm uses sketching to build a preconditioner, and then uses the preconditioner
in an iterative method. While technically the solution found is approximate (due to the use
of an iterative method), the threshold is set close to machine precision
so the solution&#8217;s accuracy is close to the full accuracy possible on a machine.</p>
<dl class="docutils">
<dt>The algorithm used is the one described in:</dt>
<dd><ul class="first last">
<li><div class="first line-block">
<div class="line">H. Avron, P. Maymounkov, and S. Toledo</div>
<div class="line"><a class="reference external" href="http://epubs.siam.org/doi/abs/10.1137/090767911">Blendenpik: Supercharging LAPACK&#8217;s Least-Squares Solver</a></div>
<div class="line">SIAM Journal on Scientific Computing 32(3), 1217-1236, 2010</div>
</div>
</li>
</ul>
</dd>
</dl>
<p>Note: it is assume that a <span class="math">4 n^2</span> matrix can fit in the memory of a single node
(<span class="math">n</span> is the number of columns in <span class="math">A</span>).</p>
<hr class="docutils" />
<dl class="function">
<dt id="FasterLeastSquares__El::Orientation.El::DistMatrix:T.El::VC.El::STAR:CR.El::DistMatrix:T.El::VC.El::STAR:CR.El::DistMatrix:T.El::STAR.El::STAR:R.base::context_tR">
void <tt class="descname">FasterLeastSquares</tt><big>(</big>El::Orientation <em>orientation</em>, const El::DistMatrix&lt;T, El::VC, El::STAR&gt;&amp; <em>A</em>, const El::DistMatrix&lt;T, El::VC, El::STAR&gt;&amp; <em>B</em>, El::DistMatrix&lt;T, El::STAR, El::STAR&gt;&amp; <em>X</em>, base::context_t&amp; <em>context</em><big>)</big><a class="headerlink" href="#FasterLeastSquares__El::Orientation.El::DistMatrix:T.El::VC.El::STAR:CR.El::DistMatrix:T.El::VC.El::STAR:CR.El::DistMatrix:T.El::STAR.El::STAR:R.base::context_tR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>If <cite>orientation</cite> is set to <tt class="docutils literal"><span class="pre">NORMAL</span></tt>, then approximate <span class="math">\arg\min_X \|A * X - B\|_F</span>, otherwise
<cite>orientation</cite> must be equal to <tt class="docutils literal"><span class="pre">ADJOINT</span></tt> and <span class="math">\arg\min_X \|A^H * X - B\|_F</span> is approximated.</p>
<hr class="docutils" />
<p>A flavor of usage is given in the code snippet below.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;elemental.hpp&gt;</span>
<span class="cp">#include &lt;skylark.hpp&gt;</span>
<span class="p">...</span>
<span class="c1">// Setup regression problem with coefficient matrix A and target matrix B</span>
<span class="p">...</span>

<span class="n">skybase</span><span class="o">::</span><span class="kt">context_t</span> <span class="n">context</span><span class="p">(</span><span class="mi">23234</span><span class="p">);</span>

<span class="c1">// Solve the Least Squres problem of minimizing || AX - B||_2 over X</span>
<span class="n">skylark</span><span class="o">::</span><span class="n">nla</span><span class="o">::</span><span class="n">FasterLeastSquares</span><span class="p">(</span><span class="n">El</span><span class="o">::</span><span class="n">NORMAL</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="randomized-singular-value-decomposition">
<h2>Randomized Singular Value Decomposition<a class="headerlink" href="#randomized-singular-value-decomposition" title="Permalink to this headline">¶</a></h2>
<p>The randomized SVD functionality provides a distributed implementation of algorithms described in</p>
<blockquote>
<div><blockquote>
<div><ul>
<li><div class="first line-block">
<div class="line">Halko, N. and Martinsson, P.G, and Tropp J.</div>
<div class="line"><a class="reference external" href="http://arxiv.org/abs/0909.4061">Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions</a></div>
<div class="line">SIAM Rev., Survey and Review section, Vol. 53, num. 2, pp. 217-288, 2011</div>
</div>
</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>The prototypical algorithm involves the following steps, given a matrix <span class="math">A</span></dt>
<dd><ul class="first last simple">
<li>Compute an approximate orthonormal basis for the range of <span class="math">A</span>, as specified by the columns of an orthonormal matrix <span class="math">Q</span>.</li>
<li>Use <span class="math">Q</span> to compute a standard factorization of <span class="math">A</span>.</li>
</ul>
</dd>
</dl>
</div></blockquote>
<p>The first step is accelerated using sketching.</p>
<div class="section" id="approximate-svd">
<h3>Approximate SVD<a class="headerlink" href="#approximate-svd" title="Permalink to this headline">¶</a></h3>
<p>Compute an approximate SVD in the sense that <span class="math">A \approx U S V^T</span>. The inner
dimension <span class="math">k</span> is specified by the user as parameter.</p>
<dl class="function">
<dt id="ApproximateSVD__InputTypeR.UTypeR.STypeR.VTypeR.i.base::context_tR.approximate_svd_params_t">
void <tt class="descname">ApproximateSVD</tt><big>(</big>InputType&amp; <em>A</em>, UType&amp; <em>U</em>, SType&amp; <em>S</em>, VType&amp; <em>V</em>, int <em>rank</em>, base::context_t&amp; <em>context</em>, approximate_svd_params_t <em>params</em><em>=approximate_svd_params_t()</em><big>)</big><a class="headerlink" href="#ApproximateSVD__InputTypeR.UTypeR.STypeR.VTypeR.i.base::context_tR.approximate_svd_params_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>For a running example, please see <em>libskylark/examples/svd.cpp</em>. This example provides a
complete driver for running this functionality from command-line.</p>
</div>
</div>
<div class="section" id="condition-number-estimation">
<h2>Condition Number Estimation<a class="headerlink" href="#condition-number-estimation" title="Permalink to this headline">¶</a></h2>
<p>Estimate the condition number of a matrix using a low-memory iterative method. Only
the ability to multiply the matrix by a vector, and its transpose by a vector is
required. No factorization is involved, so can estimate the condition number of very
large and unstructured matrices.</p>
<dl class="docutils">
<dt>The algorithm used is the one described in:</dt>
<dd><ul class="first last">
<li><div class="first line-block">
<div class="line">H. Avron, A. Durinsky, and S. Toledo</div>
<div class="line"><a class="reference external" href="http://arxiv.org/pdf/1301.1107v3.pdf">Spectral Condition-Number Estimation of Large Sparse Matrices</a></div>
</div>
</li>
</ul>
</dd>
</dl>
<dl class="function">
<dt id="CondEst__MatrixTypeCR.doubleR.doubleR.RightTypeR.LeftTypeR.doubleR.doubleR.RightTypeR.LeftTypeR.base::context_tR.condest_params_t">
int <tt class="descname">CondEst</tt><big>(</big>const MatrixType&amp; <em>A</em>, double&amp; <em>cond</em>, double&amp; <em>sigma_max</em>, RightType&amp; <em>v_max</em>, LeftType&amp; <em>u_max</em>, double&amp; <em>sigma_min</em>, double&amp; <em>sigma_min_c</em>, RightType&amp; <em>v_min</em>, LeftType&amp; <em>u_min</em>, base::context_t&amp; <em>context</em>, condest_params_t <em>params</em><em>=condest_params_t()</em><big>)</big><a class="headerlink" href="#CondEst__MatrixTypeCR.doubleR.doubleR.RightTypeR.LeftTypeR.doubleR.doubleR.RightTypeR.LeftTypeR.base::context_tR.condest_params_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the condition number of <span class="math">A</span>: estimate the largest and smallest
singular value. The estimate of the largest is highly accurate, and the
estimate of the lowest is typically a  not-too-bad upper bound. Returns also
certificate left and right vectors. For the
smallest singular vector, two estimates are returned: one with a certificate, and
one that is potentially (but not always) smaller but without certificate (it will
never be bigger than the estimate with certificate).</p>
</dd></dl>

</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="sketching.html">Sketching Layer</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="ml.html">Machine Learning</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright IBM Corporation 2012-2014.  All Rights Reserved.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>