<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Machine Learning &mdash; libSkylark  documentation</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="libSkylark  documentation" href="index.html" />
    <link rel="next" title="IO in libSkylark" href="io.html" />
    <link rel="prev" title="Numerical Linear Algebra Primitives" href="nla.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>libSkylark  documentation</span></a></h1>
        <h2 class="heading"><span>Machine Learning</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="nla.html">Numerical Linear Algebra Primitives</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="io.html">IO in libSkylark</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="machine-learning">
<h1>Machine Learning<a class="headerlink" href="#machine-learning" title="Permalink to this headline">¶</a></h1>
<div class="section" id="randomized-kernel-methods">
<h2>Randomized Kernel Methods<a class="headerlink" href="#randomized-kernel-methods" title="Permalink to this headline">¶</a></h2>
<p>libSkylark provides distributed implementations of kernel-based nonlinear models for</p>
<blockquote>
<div><ul class="simple">
<li>Regularized Least Squares Regression and Classification</li>
<li>Regularized Robust Regression (Least Absolute Deviation loss)</li>
<li>Support Vector Machines</li>
<li>Multinomial Logistic Regression (classes &gt; 2).</li>
</ul>
</div></blockquote>
<p>The following kernels are supported:</p>
<blockquote>
<div><ul class="simple">
<li>Gaussian, Laplacian and Matern Kernels via Random Fourier Transform (<a class="reference external" href="http://www.eecs.berkeley.edu/~brecht/papers/07.rah.rec.nips.pdf">Rahimi and Recht, 2007</a>)</li>
<li>Gaussian and Matern Kernels via Fast Random Fourier Transform (<a class="reference external" href="http://jmlr.org/proceedings/papers/v28/le13.html">Le, Sarlos and Smola, 2013</a>)</li>
<li>Gaussian and Matern Kernels via Quasi Random Fourier Transform (<a class="reference external" href="http://jmlr.org/proceedings/papers/v32/yangb14.pdf">Yang et al, 2014</a>)</li>
<li>Polynomial Kernels via Tensor Sketch (<a class="reference external" href="http://www.itu.dk/people/ndap/TensorSketch.pdf">Pahm and Pagh, 2013</a>)</li>
<li>Exponential Semigroup Kernels via Random Laplace Transform (<a class="reference external" href="http://vikas.sindhwani.org/RandomLaplace.pdf">Yang et al, 2014</a>)</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>The implementations combine two ideas:</dt>
<dd><ul class="first last simple">
<li>Constructing randomized approximations to Kernel functions <em>on the fly</em></li>
<li>Using a distributed optimization solver based on Alternating Directions Method of Multipliers (ADMM)</li>
</ul>
</dd>
</dl>
<p>The distributed optimization approach is based on a block-splitting variant of ADMM proposed in <a class="reference external" href="http://web.stanford.edu/~boyd/papers/block_splitting.html">Parikh and Boyd, 2014</a></p>
<dl class="docutils">
<dt>The full implementation (under <tt class="docutils literal"><span class="pre">libskylark/ml</span></tt>) is described in the following paper:</dt>
<dd><ul class="first last simple">
<li>Sindhwani V. and Avron H., High-performance Kernel Machines with Implicit Distributed Optimization and Randomization, 2014</li>
</ul>
</dd>
</dl>
<div class="section" id="standalone-usage">
<h3>Standalone Usage<a class="headerlink" href="#standalone-usage" title="Permalink to this headline">¶</a></h3>
<p>Building libSkylark creates an executable called <strong>skylark_ml</strong> under CMAKE_PREFIX_INSTALL/bin. This executable can be
used out-of-the-box for large-scale applications involving kernel-based modeling.</p>
</div>
<div class="section" id="input-data-format">
<span id="ml-io"></span><h3>Input Data Format<a class="headerlink" href="#input-data-format" title="Permalink to this headline">¶</a></h3>
<p>The implementation supports <a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/">LIBSVM</a> file format, where
feature vectors and labels are specified as</p>
<div class="highlight-python"><div class="highlight"><pre>0 1:0.2 4:0.5 10:0.3
5 3:0.3 6:0.1
</pre></div>
</div>
<p>Each line begins with a label and followed by index (starting with 1)-value pairs describing the feature vector in
sparse format.</p>
<p>We also support <a class="reference external" href="http://www.hdfgroup.org/HDF5/">HDF5</a> data files.</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>Dense training data can be described using HDF5 files containing two <a class="reference external" href="http://www.hdfgroup.org/HDF5/Tutor/crtdat.html">HDF5 datasets</a>:</dt>
<dd><ul class="first last simple">
<li><em>X</em> &#8211; n x d matrix  (examples-by-features)</li>
<li><em>Y</em> &#8211; n x 1 matrix of labels.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Sparse training data can be described using HDF5 files containing five <a class="reference external" href="http://www.hdfgroup.org/HDF5/Tutor/crtdat.html">HDF5 datasets</a> specifying a Compressed Row Storage Sparse matrix:</dt>
<dd><ul class="first last simple">
<li><em>dimensions</em>: 3 x 1 matrix [number of features, number of examples, number of nonzeros (nnz)]</li>
<li><em>indices</em>: nnz x 1 matrix column indices of non-zero values for CRS datastructure representing the examples-by-features sparse matrix</li>
<li><em>values</em>: nnz x 1 non-zero values corresponding to indices</li>
<li><em>indptr</em>: (n+1) x 1 - pointer into indices, values specifying rows</li>
<li><em>Y</em>: n x 1 matrix of labels</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Examples of such files can be downloaded from <a class="reference external" href="http://vikas.sindhwani.org/data.tar.gz">here</a>. The HDF5 files can be viewed using <a class="reference external" href="http://http://www.hdfgroup.org/HDF5/Tutor/hdfview.html">HDFView</a>. A screenshot is shown below.</p>
<a class="reference internal image-reference" href="_images/hdfview_screenshot.png"><img alt="_images/hdfview_screenshot.png" class="align-center" src="_images/hdfview_screenshot.png" style="width: 750px;" /></a>
</div>
<div class="section" id="example-and-commandline-usage">
<h3>Example and Commandline Usage<a class="headerlink" href="#example-and-commandline-usage" title="Permalink to this headline">¶</a></h3>
<p>Please see <a class="reference internal" href="quick_start.html#ml-example"><em>Learning Non-Linear Models</em></a></p>
<div class="highlight-python"><div class="highlight"><pre>Usage: skylark_ml [options] --trainfile trainfile --modelfile modelfile
Usage: skylark_ml --modelfile modelfile --testfile testfile :
  -h [ --help ]                         produce a help message
  -l [ --lossfunction ] arg (=0)        Loss function (0:SQUARED, 1:LAD,
                                        2:HINGE, 3:LOGISTIC)
  -r [ --regularizer ] arg (=0)         Regularizer (0:L2, 1:L1)
  -k [ --kernel ] arg (=0)              Kernel (0:LINEAR, 1:GAUSSIAN,
                                        2:POLYNOMIAL, 3:LAPLACIAN,
                                        4:EXPSEMIGROUP, 5:MATERN)
  -g [ --kernelparam ] arg (=1)         Kernel Parameter
  -x [ --kernelparam2 ] arg (=0)        If Applicable - Second Kernel Parameter
                                        (Polynomial Kernel: c)
  -y [ --kernelparam3 ] arg (=1)        If Applicable - Third Kernel Parameter
                                        (Polynomial Kernel: gamma)
  -c [ --lambda ] arg (=0)              Regularization Parameter
  -e [ --tolerance ] arg (=0.001)       Tolerance
  --rho arg (=1)                        ADMM rho parameter
  -s [ --seed ] arg (=12345)            Seed for Random Number Generator
  -f [ --randomfeatures ] arg (=100)    Number of Random Features (default:
                                        100)
  -n [ --numfeaturepartitions ] arg (=1)
                                        Number of Feature Partitions (default:
                                        1)
  -t [ --numthreads ] arg (=1)          Number of Threads (default: 1)
  --regression                          Build a regression model(default is
                                        classification).
  --usefast                             Use &#39;fast&#39; feature mapping, if
                                        available. Default is to use &#39;regular&#39;
                                        mapping.
  -q [ --usequasi ] arg (=0)            If possible, change the underlying
                                        sequence of samples (0:Regular/Monte
                                        Carlo, 1:Leaped Halton)
  --cachetransforms                     Cache feature expanded data (faster,
                                        but more memory demanding).
  --fileformat arg (=0)                 Fileformat (default: 0 (libsvm-&gt;dense),
                                        1 (libsvm-&gt;sparse), 2 (hdf5-&gt;dense), 3
                                        (hdf5-&gt;sparse)
  -i [ --MAXITER ] arg (=20)            Maximum Number of Iterations (default:
                                        10)
  --trainfile arg                       Training data file (required in
                                        training mode)
  --modelfile arg                       Model output file
  --valfile arg                         Validation file (optional)
  --testfile arg                        Test file (required in testing mode)
  --outputfile arg                      Base name for output file (will attach
                                        .txt suffix)
</pre></div>
</div>
</div>
<div class="section" id="library-usage">
<h3>Library Usage<a class="headerlink" href="#library-usage" title="Permalink to this headline">¶</a></h3>
<p>To be documented (please see <tt class="docutils literal"><span class="pre">ml/skylark_ml.cpp</span></tt> for a driver program).</p>
</div>
</div>
<div class="section" id="graph-computations">
<h2>Graph Computations<a class="headerlink" href="#graph-computations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="community-detection-using-seed-nodes">
<h3>Community Detection using Seed Nodes<a class="headerlink" href="#community-detection-using-seed-nodes" title="Permalink to this headline">¶</a></h3>
<p>In community detection problems (i.e., graph clustering problems), one seeks to identify a set
of nodes in a graph that are both internally cohesive and also well separated from the remainder
of the graph. Such sets are then referred to as communities or clusters. In one important variant
of community detection, the goal is to build a community around a given seed node or set of seed
nodes. That is, the algorithm is given, as an input, a node (or nodes) in the graph, and the
goal is to find a cluster in which it is a member.</p>
<dl class="docutils">
<dt>The library implements the algorithm reported in the following paper:</dt>
<dd><ul class="first last">
<li><div class="first line-block">
<div class="line">H. Avron and L. Horesh</div>
<div class="line">Community Detection Using Time-Dependent Personalized PageRank</div>
</div>
</li>
</ul>
</dd>
</dl>
<p>The interface is as follows:</p>
<dl class="function">
<dt id="FindLocalCluster__GraphTypeCR.std::unordered_set:typename-GraphType::vertex_type:CR.std::unordered_set:typename-GraphType::vertex_type:R.double.double.double.i.b">
double <tt class="descname">FindLocalCluster</tt><big>(</big>const GraphType&amp; <em>G</em>, const std::unordered_set&lt;typename GraphType::vertex_type&gt;&amp; <em>seeds</em>, std::unordered_set&lt;typename GraphType::vertex_type&gt;&amp; <em>cluster</em>, double <em>alpha</em>, double <em>gamma</em>, double <em>epsilon</em>, int <em>NX</em>, bool <em>recursive</em><big>)</big><a class="headerlink" href="#FindLocalCluster__GraphTypeCR.std::unordered_set:typename-GraphType::vertex_type:CR.std::unordered_set:typename-GraphType::vertex_type:R.double.double.double.i.b" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>seeds is the set of input seeds, cluster is the set of output cluster. alpha, gamma, epsilon and NX are
parameters of the algorithm. See paper for details. Defaults are specified.
If recursive is set to true (default is false)
the algorithm will recursively use the output cluster as seed until the cluster stops
improving (as measured using conductance).</p>
<p>The graph is specified using parameter G. The type is generic: the GraphType class is expected to
support the following:</p>
<dl class="type">
<dt id="GraphType::vertex_type">
<em class="property">type </em><tt class="descclassname">GraphType::</tt><tt class="descname">vertex_type</tt><a class="headerlink" href="#GraphType::vertex_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Type of the graph nodes</p>
<dl class="function">
<dt id="GraphType::num_edges">
size_t <tt class="descclassname">GraphType::</tt><tt class="descname">num_edges</tt><big>(</big><big>)</big><a class="headerlink" href="#GraphType::num_edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Return the number of edges in the graph.</p>
<dl class="function">
<dt id="GraphType::deg__vertex_type">
size_t <tt class="descclassname">GraphType::</tt><tt class="descname">deg</tt><big>(</big>vertex_type <em>node</em><big>)</big><a class="headerlink" href="#GraphType::deg__vertex_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Return the degree of the given node.</p>
<dl class="function">
<dt id="GraphType::adjanct_begin__vertex_type">
iterator <tt class="descclassname">GraphType::</tt><tt class="descname">adjanct_begin</tt><big>(</big>vertex_type <em>node</em><big>)</big><a class="headerlink" href="#GraphType::adjanct_begin__vertex_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Return an iterator to the start of the list of adjanct nodes of the input
node. The iterator can be of any kind (must support increment, deref and comparison).</p>
<dl class="function">
<dt id="GraphType::adjanct_end__vertex_type">
iterator <tt class="descclassname">GraphType::</tt><tt class="descname">adjanct_end</tt><big>(</big>vertex_type <em>node</em><big>)</big><a class="headerlink" href="#GraphType::adjanct_end__vertex_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Return an iterator to the end of the list of adjanct nodes of the input
node.</p>
</div>
<div class="section" id="time-dependent-personalized-pagerank">
<h3>Time-Dependent Personalized PageRank<a class="headerlink" href="#time-dependent-personalized-pagerank" title="Permalink to this headline">¶</a></h3>
<p>The community detection algorithm is based on a localized solution of
a Time-Dependent Personlized PageRank diffusion problem. See the
paper for details:</p>
<blockquote>
<div><ul>
<li><div class="first line-block">
<div class="line">H. Avron and L. Horesh</div>
<div class="line">Community Detection Using Time-Dependent Personalized PageRank</div>
</div>
</li>
</ul>
</div></blockquote>
<p>The library also exposes the ability to solve the diffusion problem.
In this functionality, the input is a scalar function on nodes, and the
output is a vector function on nodes. Each entry of the vector
represents a different time point.</p>
<p>The interface is as follows:</p>
<dl class="function">
<dt id="TimeDependentPPR__GraphTypeCR.std::unordered_map:typename-GraphType::vertex_type.T:CR.std::unordered_map:typename-GraphType::vertex_type.El::Matrix:T:P:R.El::Matrix:T:R.double.double.double.i">
void <tt class="descname">TimeDependentPPR</tt><big>(</big>const GraphType&amp; <em>G</em>, const std::unordered_map&lt;typename GraphType::vertex_type, T&gt;&amp; <em>s</em>, std::unordered_map&lt;typename GraphType::vertex_type, El::Matrix&lt;T&gt;*&gt;&amp; <em>y</em>, El::Matrix&lt;T&gt;&amp; <em>x</em>, double <em>alpha</em>, double <em>gamma</em>, double <em>epsilon</em>, int <em>NX</em><big>)</big><a class="headerlink" href="#TimeDependentPPR__GraphTypeCR.std::unordered_map:typename-GraphType::vertex_type.T:CR.std::unordered_map:typename-GraphType::vertex_type.El::Matrix:T:P:R.El::Matrix:T:R.double.double.double.i" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>s is the input function of nodes, while y is the output. x specifies the time points which
corresponds to the entries of x[node]. alpha, gamma, epsilon and NX are
parameters of the algorithm. See paper for details. Defaults are specified.</p>
<p>The graph is specified using parameter G. The type is generic: the GraphType class is expected to
support the following:</p>
<dl class="type">
<dt>
<em class="property">type </em><tt class="descclassname">GraphType::</tt><tt class="descname">vertex_type</tt></dt>
<dd></dd></dl>

<p>Type of the graph nodes</p>
<dl class="function">
<dt>
size_t <tt class="descclassname">GraphType::</tt><tt class="descname">num_edges</tt><big>(</big><big>)</big></dt>
<dd></dd></dl>

<p>Return the number of edges in the graph.</p>
<dl class="function">
<dt>
size_t <tt class="descclassname">GraphType::</tt><tt class="descname">deg</tt><big>(</big>vertex_type <em>node</em><big>)</big></dt>
<dd></dd></dl>

<p>Return the degree of the given node.</p>
<dl class="function">
<dt>
iterator <tt class="descclassname">GraphType::</tt><tt class="descname">adjanct_begin</tt><big>(</big>vertex_type <em>node</em><big>)</big></dt>
<dd></dd></dl>

<p>Return an iterator to the start of the list of adjanct nodes of the input
node. The iterator can be of any kind (must support increment, deref and comparison).</p>
<dl class="function">
<dt>
iterator <tt class="descclassname">GraphType::</tt><tt class="descname">adjanct_end</tt><big>(</big>vertex_type <em>node</em><big>)</big></dt>
<dd></dd></dl>

<p>Return an iterator to the end of the list of adjanct nodes of the input
node.</p>
</div>
<div class="section" id="approximate-adjacency-spectral-embedding">
<h3>Approximate Adjacency Spectral Embedding<a class="headerlink" href="#approximate-adjacency-spectral-embedding" title="Permalink to this headline">¶</a></h3>
<p>The goal of graph embedding is to assign each vertex a vector such
that closeness in Euclidean space is well correlated with closeness
in graph distance. Spectral embedding base the embedding on the eigenvalue
decomposition of some associated matrix. In Adjacency Spectral Embedding (ASE)
the embedding is computed using the eigenvalue decomposition of the adjacency matrix.</p>
<p>The library implements a sketched-SVD based approximate ASE, based on the description
of ASE found in:</p>
<blockquote>
<div><ul>
<li><div class="first line-block">
<div class="line">V. Lyzinski et al.</div>
<div class="line">Community Detection and Classification in Hierarchical Stochastic Blockmodels</div>
</div>
</li>
</ul>
</div></blockquote>
<p>The interface is as follows:</p>
<dl class="function">
<dt id="ApproximateASE__GraphTypeCR.i.std::vector:typename-GraphType::vertex_type:R.El::Matrix:T:R.base::context_tR.approximate_ase_params_t">
void <tt class="descname">ApproximateASE</tt><big>(</big>const GraphType&amp; <em>G</em>, int <em>k</em>, std::vector&lt;typename GraphType::vertex_type&gt;&amp; <em>indexmap</em>, El::Matrix&lt;T&gt;&amp; <em>X</em>, base::context_t&amp; <em>context</em>, approximate_ase_params_t <em>params</em><big>)</big><a class="headerlink" href="#ApproximateASE__GraphTypeCR.i.std::vector:typename-GraphType::vertex_type:R.El::Matrix:T:R.base::context_tR.approximate_ase_params_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>X will be filled with the embedding. Each row of X is associated with one vertex. indexmap is a map between row index
and the vertex. The parameter structure is similar to the one specified to approximate SVD.</p>
<p>The graph is specified using parameter G. The type is generic: the GraphType class is expected to
support the following:</p>
<dl class="type">
<dt>
<em class="property">type </em><tt class="descclassname">GraphType::</tt><tt class="descname">vertex_type</tt></dt>
<dd></dd></dl>

<p>Type of the graph nodes</p>
<dl class="function">
<dt id="GraphType::adjacency_matrix__base::sparse_matrix_t:T:R.std::vector:vertex_type:R">
size_t <tt class="descclassname">GraphType::</tt><tt class="descname">adjacency_matrix</tt><big>(</big>base::sparse_matrix_t&lt;T&gt;&amp; <em>A</em>, std::vector&lt;vertex_type&gt;&amp; <em>indexmap</em><big>)</big><a class="headerlink" href="#GraphType::adjacency_matrix__base::sparse_matrix_t:T:R.std::vector:vertex_type:R" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Fills the adjacency matrix of the graph</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently, approximate ASE is computed only on a single machine, and no MPI (OpenMP is used, but in a limited manner).
This will change in the future.</p>
</div>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="nla.html">Numerical Linear Algebra Primitives</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="io.html">IO in libSkylark</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright IBM Corporation 2012-2014.  All Rights Reserved.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>