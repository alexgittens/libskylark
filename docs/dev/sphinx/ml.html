<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Machine Learning &mdash; libSkylark  documentation</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="libSkylark  documentation" href="index.html" />
    <link rel="next" title="IO in libSkylark" href="io.html" />
    <link rel="prev" title="Numerical Linear Algebra Primitives" href="nla.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>libSkylark  documentation</span></a></h1>
        <h2 class="heading"><span>Machine Learning</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="nla.html">Numerical Linear Algebra Primitives</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="io.html">IO in libSkylark</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="machine-learning">
<h1>Machine Learning<a class="headerlink" href="#machine-learning" title="Permalink to this headline">¶</a></h1>
<div class="section" id="randomized-kernel-methods">
<h2>Randomized Kernel Methods<a class="headerlink" href="#randomized-kernel-methods" title="Permalink to this headline">¶</a></h2>
<p>libSkylark provides distributed implementations of kernel-based nonlinear models for</p>
<blockquote>
<div><ul class="simple">
<li>Regularized Least Squares Regression and Classification</li>
<li>Regularized Robust Regression (Least Absolute Deviation loss)</li>
<li>Support Vector Machines</li>
<li>Multinomial Logistic Regression (classes &gt; 2).</li>
</ul>
</div></blockquote>
<p>The following kernels are supported:</p>
<blockquote>
<div><ul class="simple">
<li>Gaussian, Laplacian and Matern Kernels via Random Fourier Transform (<a class="reference external" href="http://www.eecs.berkeley.edu/~brecht/papers/07.rah.rec.nips.pdf">Rahimi and Recht, 2007</a>)</li>
<li>Gaussian and Matern Kernels via Fast Random Fourier Transform (<a class="reference external" href="http://jmlr.org/proceedings/papers/v28/le13.html">Le, Sarlos and Smola, 2013</a>)</li>
<li>Gaussian and Matern Kernels via Quasi Random Fourier Transform (<a class="reference external" href="http://jmlr.org/proceedings/papers/v32/yangb14.pdf">Yang et al, 2014</a>)</li>
<li>Polynomial Kernels via Tensor Sketch (<a class="reference external" href="http://www.itu.dk/people/ndap/TensorSketch.pdf">Pahm and Pagh, 2013</a>)</li>
<li>Exponential Semigroup Kernels via Random Laplace Transform (<a class="reference external" href="http://vikas.sindhwani.org/RandomLaplace.pdf">Yang et al, 2014</a>)</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>The implementations combine two ideas:</dt>
<dd><ul class="first last simple">
<li>Constructing randomized approximations to Kernel functions <em>on the fly</em></li>
<li>Using a distributed optimization solver based on Alternating Directions Method of Multipliers (ADMM)</li>
</ul>
</dd>
</dl>
<p>The distributed optimization approach is based on a block-splitting variant of ADMM proposed in <a class="reference external" href="http://web.stanford.edu/~boyd/papers/block_splitting.html">Parikh and Boyd, 2014</a></p>
<dl class="docutils">
<dt>The full implementation (under <code class="docutils literal"><span class="pre">libskylark/ml</span></code>) is described in the following paper:</dt>
<dd><ul class="first last simple">
<li>Sindhwani V. and Avron H., High-performance Kernel Machines with Implicit Distributed Optimization and Randomization, 2014</li>
</ul>
</dd>
</dl>
<div class="section" id="standalone-usage">
<h3>Standalone Usage<a class="headerlink" href="#standalone-usage" title="Permalink to this headline">¶</a></h3>
<p>Building libSkylark creates an executable called <strong>skylark_ml</strong> under CMAKE_PREFIX_INSTALL/bin. This executable can be
used out-of-the-box for large-scale applications involving kernel-based modeling.</p>
</div>
<div class="section" id="input-data-format">
<span id="ml-io"></span><h3>Input Data Format<a class="headerlink" href="#input-data-format" title="Permalink to this headline">¶</a></h3>
<p>The implementation supports <a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/">LIBSVM</a> file format, where
feature vectors and labels are specified as</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="mi">1</span><span class="p">:</span><span class="mf">0.2</span> <span class="mi">4</span><span class="p">:</span><span class="mf">0.5</span> <span class="mi">10</span><span class="p">:</span><span class="mf">0.3</span>
<span class="mi">5</span> <span class="mi">3</span><span class="p">:</span><span class="mf">0.3</span> <span class="mi">6</span><span class="p">:</span><span class="mf">0.1</span>
</pre></div>
</div>
<p>Each line begins with a label and followed by index (starting with 1)-value pairs describing the feature vector in
sparse format.</p>
<p>We also support <a class="reference external" href="http://www.hdfgroup.org/HDF5/">HDF5</a> data files.</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>Dense training data can be described using HDF5 files containing two <a class="reference external" href="http://www.hdfgroup.org/HDF5/Tutor/crtdat.html">HDF5 datasets</a>:</dt>
<dd><ul class="first last simple">
<li><em>X</em> &#8211; n x d matrix  (examples-by-features)</li>
<li><em>Y</em> &#8211; n x 1 matrix of labels.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Sparse training data can be described using HDF5 files containing five <a class="reference external" href="http://www.hdfgroup.org/HDF5/Tutor/crtdat.html">HDF5 datasets</a> specifying a Compressed Row Storage Sparse matrix:</dt>
<dd><ul class="first last simple">
<li><em>dimensions</em>: 3 x 1 matrix [number of features, number of examples, number of nonzeros (nnz)]</li>
<li><em>indices</em>: nnz x 1 matrix column indices of non-zero values for CRS datastructure representing the examples-by-features sparse matrix</li>
<li><em>values</em>: nnz x 1 non-zero values corresponding to indices</li>
<li><em>indptr</em>: (n+1) x 1 - pointer into indices, values specifying rows</li>
<li><em>Y</em>: n x 1 matrix of labels</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Examples of such files can be downloaded from <a class="reference external" href="http://vikas.sindhwani.org/data.tar.gz">here</a>. The HDF5 files can be viewed using <a class="reference external" href="http://http://www.hdfgroup.org/HDF5/Tutor/hdfview.html">HDFView</a>. A screenshot is shown below.</p>
<a class="reference internal image-reference" href="_images/hdfview_screenshot.png"><img alt="_images/hdfview_screenshot.png" class="align-center" src="_images/hdfview_screenshot.png" style="width: 750px;" /></a>
</div>
<div class="section" id="example-and-commandline-usage">
<h3>Example and Commandline Usage<a class="headerlink" href="#example-and-commandline-usage" title="Permalink to this headline">¶</a></h3>
<p>Please see <a class="reference internal" href="quick_start.html#ml-example"><span class="std std-ref">Learning Non-Linear Models</span></a></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Usage</span><span class="p">:</span> <span class="n">skylark_ml</span> <span class="p">[</span><span class="n">options</span><span class="p">]</span> <span class="o">--</span><span class="n">trainfile</span> <span class="n">trainfile</span> <span class="o">--</span><span class="n">modelfile</span> <span class="n">modelfile</span>
<span class="n">Usage</span><span class="p">:</span> <span class="n">skylark_ml</span> <span class="o">--</span><span class="n">modelfile</span> <span class="n">modelfile</span> <span class="o">--</span><span class="n">testfile</span> <span class="n">testfile</span> <span class="p">:</span>
  <span class="o">-</span><span class="n">h</span> <span class="p">[</span> <span class="o">--</span><span class="n">help</span> <span class="p">]</span>                         <span class="n">produce</span> <span class="n">a</span> <span class="n">help</span> <span class="n">message</span>
  <span class="o">-</span><span class="n">l</span> <span class="p">[</span> <span class="o">--</span><span class="n">lossfunction</span> <span class="p">]</span> <span class="n">arg</span> <span class="p">(</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>        <span class="n">Loss</span> <span class="n">function</span> <span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="n">SQUARED</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">LAD</span><span class="p">,</span>
                                        <span class="mi">2</span><span class="p">:</span><span class="n">HINGE</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="n">LOGISTIC</span><span class="p">)</span>
  <span class="o">-</span><span class="n">r</span> <span class="p">[</span> <span class="o">--</span><span class="n">regularizer</span> <span class="p">]</span> <span class="n">arg</span> <span class="p">(</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>         <span class="n">Regularizer</span> <span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="n">L2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">L1</span><span class="p">)</span>
  <span class="o">-</span><span class="n">k</span> <span class="p">[</span> <span class="o">--</span><span class="n">kernel</span> <span class="p">]</span> <span class="n">arg</span> <span class="p">(</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>              <span class="n">Kernel</span> <span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="n">LINEAR</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">GAUSSIAN</span><span class="p">,</span>
                                        <span class="mi">2</span><span class="p">:</span><span class="n">POLYNOMIAL</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="n">LAPLACIAN</span><span class="p">,</span>
                                        <span class="mi">4</span><span class="p">:</span><span class="n">EXPSEMIGROUP</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="n">MATERN</span><span class="p">)</span>
  <span class="o">-</span><span class="n">g</span> <span class="p">[</span> <span class="o">--</span><span class="n">kernelparam</span> <span class="p">]</span> <span class="n">arg</span> <span class="p">(</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>         <span class="n">Kernel</span> <span class="n">Parameter</span>
  <span class="o">-</span><span class="n">x</span> <span class="p">[</span> <span class="o">--</span><span class="n">kernelparam2</span> <span class="p">]</span> <span class="n">arg</span> <span class="p">(</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>        <span class="n">If</span> <span class="n">Applicable</span> <span class="o">-</span> <span class="n">Second</span> <span class="n">Kernel</span> <span class="n">Parameter</span>
                                        <span class="p">(</span><span class="n">Polynomial</span> <span class="n">Kernel</span><span class="p">:</span> <span class="n">c</span><span class="p">)</span>
  <span class="o">-</span><span class="n">y</span> <span class="p">[</span> <span class="o">--</span><span class="n">kernelparam3</span> <span class="p">]</span> <span class="n">arg</span> <span class="p">(</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>        <span class="n">If</span> <span class="n">Applicable</span> <span class="o">-</span> <span class="n">Third</span> <span class="n">Kernel</span> <span class="n">Parameter</span>
                                        <span class="p">(</span><span class="n">Polynomial</span> <span class="n">Kernel</span><span class="p">:</span> <span class="n">gamma</span><span class="p">)</span>
  <span class="o">-</span><span class="n">c</span> <span class="p">[</span> <span class="o">--</span><span class="k">lambda</span> <span class="p">]</span> <span class="n">arg</span> <span class="p">(</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>              <span class="n">Regularization</span> <span class="n">Parameter</span>
  <span class="o">-</span><span class="n">e</span> <span class="p">[</span> <span class="o">--</span><span class="n">tolerance</span> <span class="p">]</span> <span class="n">arg</span> <span class="p">(</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span>       <span class="n">Tolerance</span>
  <span class="o">--</span><span class="n">rho</span> <span class="n">arg</span> <span class="p">(</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>                        <span class="n">ADMM</span> <span class="n">rho</span> <span class="n">parameter</span>
  <span class="o">-</span><span class="n">s</span> <span class="p">[</span> <span class="o">--</span><span class="n">seed</span> <span class="p">]</span> <span class="n">arg</span> <span class="p">(</span><span class="o">=</span><span class="mi">12345</span><span class="p">)</span>            <span class="n">Seed</span> <span class="k">for</span> <span class="n">Random</span> <span class="n">Number</span> <span class="n">Generator</span>
  <span class="o">-</span><span class="n">f</span> <span class="p">[</span> <span class="o">--</span><span class="n">randomfeatures</span> <span class="p">]</span> <span class="n">arg</span> <span class="p">(</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>    <span class="n">Number</span> <span class="n">of</span> <span class="n">Random</span> <span class="n">Features</span> <span class="p">(</span><span class="n">default</span><span class="p">:</span>
                                        <span class="mi">100</span><span class="p">)</span>
  <span class="o">-</span><span class="n">n</span> <span class="p">[</span> <span class="o">--</span><span class="n">numfeaturepartitions</span> <span class="p">]</span> <span class="n">arg</span> <span class="p">(</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                                        <span class="n">Number</span> <span class="n">of</span> <span class="n">Feature</span> <span class="n">Partitions</span> <span class="p">(</span><span class="n">default</span><span class="p">:</span>
                                        <span class="mi">1</span><span class="p">)</span>
  <span class="o">-</span><span class="n">t</span> <span class="p">[</span> <span class="o">--</span><span class="n">numthreads</span> <span class="p">]</span> <span class="n">arg</span> <span class="p">(</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>          <span class="n">Number</span> <span class="n">of</span> <span class="n">Threads</span> <span class="p">(</span><span class="n">default</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
  <span class="o">--</span><span class="n">regression</span>                          <span class="n">Build</span> <span class="n">a</span> <span class="n">regression</span> <span class="n">model</span><span class="p">(</span><span class="n">default</span> <span class="ow">is</span>
                                        <span class="n">classification</span><span class="p">)</span><span class="o">.</span>
  <span class="o">--</span><span class="n">usefast</span>                             <span class="n">Use</span> <span class="s1">&#39;fast&#39;</span> <span class="n">feature</span> <span class="n">mapping</span><span class="p">,</span> <span class="k">if</span>
                                        <span class="n">available</span><span class="o">.</span> <span class="n">Default</span> <span class="ow">is</span> <span class="n">to</span> <span class="n">use</span> <span class="s1">&#39;regular&#39;</span>
                                        <span class="n">mapping</span><span class="o">.</span>
  <span class="o">-</span><span class="n">q</span> <span class="p">[</span> <span class="o">--</span><span class="n">usequasi</span> <span class="p">]</span> <span class="n">arg</span> <span class="p">(</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>            <span class="n">If</span> <span class="n">possible</span><span class="p">,</span> <span class="n">change</span> <span class="n">the</span> <span class="n">underlying</span>
                                        <span class="n">sequence</span> <span class="n">of</span> <span class="n">samples</span> <span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="n">Regular</span><span class="o">/</span><span class="n">Monte</span>
                                        <span class="n">Carlo</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="n">Leaped</span> <span class="n">Halton</span><span class="p">)</span>
  <span class="o">--</span><span class="n">cachetransforms</span>                     <span class="n">Cache</span> <span class="n">feature</span> <span class="n">expanded</span> <span class="n">data</span> <span class="p">(</span><span class="n">faster</span><span class="p">,</span>
                                        <span class="n">but</span> <span class="n">more</span> <span class="n">memory</span> <span class="n">demanding</span><span class="p">)</span><span class="o">.</span>
  <span class="o">--</span><span class="n">fileformat</span> <span class="n">arg</span> <span class="p">(</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>                 <span class="n">Fileformat</span> <span class="p">(</span><span class="n">default</span><span class="p">:</span> <span class="mi">0</span> <span class="p">(</span><span class="n">libsvm</span><span class="o">-&gt;</span><span class="n">dense</span><span class="p">),</span>
                                        <span class="mi">1</span> <span class="p">(</span><span class="n">libsvm</span><span class="o">-&gt;</span><span class="n">sparse</span><span class="p">),</span> <span class="mi">2</span> <span class="p">(</span><span class="n">hdf5</span><span class="o">-&gt;</span><span class="n">dense</span><span class="p">),</span> <span class="mi">3</span>
                                        <span class="p">(</span><span class="n">hdf5</span><span class="o">-&gt;</span><span class="n">sparse</span><span class="p">)</span>
  <span class="o">-</span><span class="n">i</span> <span class="p">[</span> <span class="o">--</span><span class="n">MAXITER</span> <span class="p">]</span> <span class="n">arg</span> <span class="p">(</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>            <span class="n">Maximum</span> <span class="n">Number</span> <span class="n">of</span> <span class="n">Iterations</span> <span class="p">(</span><span class="n">default</span><span class="p">:</span>
                                        <span class="mi">10</span><span class="p">)</span>
  <span class="o">--</span><span class="n">trainfile</span> <span class="n">arg</span>                       <span class="n">Training</span> <span class="n">data</span> <span class="n">file</span> <span class="p">(</span><span class="n">required</span> <span class="ow">in</span>
                                        <span class="n">training</span> <span class="n">mode</span><span class="p">)</span>
  <span class="o">--</span><span class="n">modelfile</span> <span class="n">arg</span>                       <span class="n">Model</span> <span class="n">output</span> <span class="n">file</span>
  <span class="o">--</span><span class="n">valfile</span> <span class="n">arg</span>                         <span class="n">Validation</span> <span class="n">file</span> <span class="p">(</span><span class="n">optional</span><span class="p">)</span>
  <span class="o">--</span><span class="n">testfile</span> <span class="n">arg</span>                        <span class="n">Test</span> <span class="n">file</span> <span class="p">(</span><span class="n">required</span> <span class="ow">in</span> <span class="n">testing</span> <span class="n">mode</span><span class="p">)</span>
  <span class="o">--</span><span class="n">outputfile</span> <span class="n">arg</span>                      <span class="n">Base</span> <span class="n">name</span> <span class="k">for</span> <span class="n">output</span> <span class="n">file</span> <span class="p">(</span><span class="n">will</span> <span class="n">attach</span>
                                        <span class="o">.</span><span class="n">txt</span> <span class="n">suffix</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="library-usage">
<h3>Library Usage<a class="headerlink" href="#library-usage" title="Permalink to this headline">¶</a></h3>
<p>To be documented (please see <code class="docutils literal"><span class="pre">ml/skylark_ml.cpp</span></code> for a driver program).</p>
</div>
</div>
<div class="section" id="graph-computations">
<h2>Graph Computations<a class="headerlink" href="#graph-computations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="community-detection-using-seed-nodes">
<h3>Community Detection using Seed Nodes<a class="headerlink" href="#community-detection-using-seed-nodes" title="Permalink to this headline">¶</a></h3>
<p>In community detection problems (i.e., graph clustering problems), one seeks to identify a set
of nodes in a graph that are both internally cohesive and also well separated from the remainder
of the graph. Such sets are then referred to as communities or clusters. In one important variant
of community detection, the goal is to build a community around a given seed node or set of seed
nodes. That is, the algorithm is given, as an input, a node (or nodes) in the graph, and the
goal is to find a cluster in which it is a member.</p>
<dl class="docutils">
<dt>The library implements the algorithm reported in the following paper:</dt>
<dd><ul class="first last">
<li><div class="first line-block">
<div class="line">H. Avron and L. Horesh</div>
<div class="line">Community Detection Using Time-Dependent Personalized PageRank</div>
</div>
</li>
</ul>
</dd>
</dl>
<p>The interface is as follows:</p>
<dl class="function">
<dt id="_CPPv216FindLocalClusterRK9GraphTypeRKNSt13unordered_setIN9GraphType11vertex_typeEEERNSt13unordered_setIN9GraphType11vertex_typeEEEdddib">
<span id="FindLocalCluster__GraphTypeCR.std::unordered_set:GraphType::vertex_type:CR.std::unordered_set:GraphType::vertex_type:R.double.double.double.i.b"></span>double <code class="descclassname"></code><code class="descname">FindLocalCluster</code><span class="sig-paren">(</span><em class="property">const</em> GraphType &amp;<em>G</em>, <em class="property">const</em> std::unordered_set&lt;<em class="property">typename</em> GraphType::<a class="reference internal" href="#_CPPv2N9GraphType11vertex_typeE" title="GraphType::vertex_type">vertex_type</a>&gt; &amp;<em>seeds</em>, std::unordered_set&lt;<em class="property">typename</em> GraphType::<a class="reference internal" href="#_CPPv2N9GraphType11vertex_typeE" title="GraphType::vertex_type">vertex_type</a>&gt; &amp;<em>cluster</em>, double <em>alpha</em>, double <em>gamma</em>, double <em>epsilon</em>, int <em>NX</em>, bool <em>recursive</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv216FindLocalClusterRK9GraphTypeRKNSt13unordered_setIN9GraphType11vertex_typeEEERNSt13unordered_setIN9GraphType11vertex_typeEEEdddib" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>seeds is the set of input seeds, cluster is the set of output cluster. alpha, gamma, epsilon and NX are
parameters of the algorithm. See paper for details. Defaults are specified.
If recursive is set to true (default is false)
the algorithm will recursively use the output cluster as seed until the cluster stops
improving (as measured using conductance).</p>
<p>The graph is specified using parameter G. The type is generic: the GraphType class is expected to
support the following:</p>
<dl class="type">
<dt id="_CPPv2N9GraphType11vertex_typeE">
<span id="GraphType::vertex_type"></span><em class="property">type </em><code class="descclassname">GraphType::</code><code class="descname">vertex_type</code><a class="headerlink" href="#_CPPv2N9GraphType11vertex_typeE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Type of the graph nodes</p>
<dl class="function">
<dt id="_CPPv2N9GraphType9num_edgesEv">
<span id="GraphType::num_edges"></span>size_t <code class="descclassname">GraphType::</code><code class="descname">num_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N9GraphType9num_edgesEv" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Return the number of edges in the graph.</p>
<dl class="function">
<dt id="_CPPv2N9GraphType3degE11vertex_type">
<span id="GraphType::deg__vertex_type"></span>size_t <code class="descclassname">GraphType::</code><code class="descname">deg</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N9GraphType11vertex_typeE" title="GraphType::vertex_type">vertex_type</a> <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N9GraphType3degE11vertex_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Return the degree of the given node.</p>
<dl class="function">
<dt id="_CPPv2N9GraphType13adjanct_beginE11vertex_type">
<span id="GraphType::adjanct_begin__vertex_type"></span>iterator <code class="descclassname">GraphType::</code><code class="descname">adjanct_begin</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N9GraphType11vertex_typeE" title="GraphType::vertex_type">vertex_type</a> <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N9GraphType13adjanct_beginE11vertex_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Return an iterator to the start of the list of adjanct nodes of the input
node. The iterator can be of any kind (must support increment, deref and comparison).</p>
<dl class="function">
<dt id="_CPPv2N9GraphType11adjanct_endE11vertex_type">
<span id="GraphType::adjanct_end__vertex_type"></span>iterator <code class="descclassname">GraphType::</code><code class="descname">adjanct_end</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N9GraphType11vertex_typeE" title="GraphType::vertex_type">vertex_type</a> <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N9GraphType11adjanct_endE11vertex_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Return an iterator to the end of the list of adjanct nodes of the input
node.</p>
</div>
<div class="section" id="time-dependent-personalized-pagerank">
<h3>Time-Dependent Personalized PageRank<a class="headerlink" href="#time-dependent-personalized-pagerank" title="Permalink to this headline">¶</a></h3>
<p>The community detection algorithm is based on a localized solution of
a Time-Dependent Personlized PageRank diffusion problem. See the
paper for details:</p>
<blockquote>
<div><ul>
<li><div class="first line-block">
<div class="line">H. Avron and L. Horesh</div>
<div class="line">Community Detection Using Time-Dependent Personalized PageRank</div>
</div>
</li>
</ul>
</div></blockquote>
<p>The library also exposes the ability to solve the diffusion problem.
In this functionality, the input is a scalar function on nodes, and the
output is a vector function on nodes. Each entry of the vector
represents a different time point.</p>
<p>The interface is as follows:</p>
<dl class="function">
<dt id="_CPPv216TimeDependentPPRRK9GraphTypeRKNSt13unordered_mapIN9GraphType11vertex_typeE1TEERNSt13unordered_mapIN9GraphType11vertex_typeEPN2El6MatrixI1TEEEERN2El6MatrixI1TEEdddi">
<span id="TimeDependentPPR__GraphTypeCR.std::unordered_map:GraphType::vertex_type.T:CR.std::unordered_map:GraphType::vertex_type.El::Matrix:T:P:R.El::Matrix:T:R.double.double.double.i"></span>void <code class="descclassname"></code><code class="descname">TimeDependentPPR</code><span class="sig-paren">(</span><em class="property">const</em> GraphType &amp;<em>G</em>, <em class="property">const</em> std::unordered_map&lt;<em class="property">typename</em> GraphType::<a class="reference internal" href="#_CPPv2N9GraphType11vertex_typeE" title="GraphType::vertex_type">vertex_type</a>, T&gt; &amp;<em>s</em>, std::unordered_map&lt;<em class="property">typename</em> GraphType::<a class="reference internal" href="#_CPPv2N9GraphType11vertex_typeE" title="GraphType::vertex_type">vertex_type</a>, El::Matrix&lt;T&gt; *&gt; &amp;<em>y</em>, El::Matrix&lt;T&gt; &amp;<em>x</em>, double <em>alpha</em>, double <em>gamma</em>, double <em>epsilon</em>, int <em>NX</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv216TimeDependentPPRRK9GraphTypeRKNSt13unordered_mapIN9GraphType11vertex_typeE1TEERNSt13unordered_mapIN9GraphType11vertex_typeEPN2El6MatrixI1TEEEERN2El6MatrixI1TEEdddi" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>s is the input function of nodes, while y is the output. x specifies the time points which
corresponds to the entries of x[node]. alpha, gamma, epsilon and NX are
parameters of the algorithm. See paper for details. Defaults are specified.</p>
<p>The graph is specified using parameter G. The type is generic: the GraphType class is expected to
support the following:</p>
<dl class="type">
<dt id="_CPPv2N9GraphType11vertex_typeE">
<span id="GraphType::vertex_type"></span><em class="property">type </em><code class="descclassname">GraphType::</code><code class="descname">vertex_type</code><a class="headerlink" href="#_CPPv2N9GraphType11vertex_typeE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Type of the graph nodes</p>
<dl class="function">
<dt id="_CPPv2N9GraphType9num_edgesEv">
<span id="GraphType::num_edges"></span>size_t <code class="descclassname">GraphType::</code><code class="descname">num_edges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N9GraphType9num_edgesEv" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Return the number of edges in the graph.</p>
<dl class="function">
<dt id="_CPPv2N9GraphType3degE11vertex_type">
<span id="GraphType::deg__vertex_type"></span>size_t <code class="descclassname">GraphType::</code><code class="descname">deg</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N9GraphType11vertex_typeE" title="GraphType::vertex_type">vertex_type</a> <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N9GraphType3degE11vertex_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Return the degree of the given node.</p>
<dl class="function">
<dt id="_CPPv2N9GraphType13adjanct_beginE11vertex_type">
<span id="GraphType::adjanct_begin__vertex_type"></span>iterator <code class="descclassname">GraphType::</code><code class="descname">adjanct_begin</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N9GraphType11vertex_typeE" title="GraphType::vertex_type">vertex_type</a> <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N9GraphType13adjanct_beginE11vertex_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Return an iterator to the start of the list of adjanct nodes of the input
node. The iterator can be of any kind (must support increment, deref and comparison).</p>
<dl class="function">
<dt id="_CPPv2N9GraphType11adjanct_endE11vertex_type">
<span id="GraphType::adjanct_end__vertex_type"></span>iterator <code class="descclassname">GraphType::</code><code class="descname">adjanct_end</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N9GraphType11vertex_typeE" title="GraphType::vertex_type">vertex_type</a> <em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N9GraphType11adjanct_endE11vertex_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Return an iterator to the end of the list of adjanct nodes of the input
node.</p>
</div>
<div class="section" id="approximate-adjacency-spectral-embedding">
<h3>Approximate Adjacency Spectral Embedding<a class="headerlink" href="#approximate-adjacency-spectral-embedding" title="Permalink to this headline">¶</a></h3>
<p>The goal of graph embedding is to assign each vertex a vector such
that closeness in Euclidean space is well correlated with closeness
in graph distance. Spectral embedding base the embedding on the eigenvalue
decomposition of some associated matrix. In Adjacency Spectral Embedding (ASE)
the embedding is computed using the eigenvalue decomposition of the adjacency matrix.</p>
<p>The library implements a sketched-SVD based approximate ASE, based on the description
of ASE found in:</p>
<blockquote>
<div><ul>
<li><div class="first line-block">
<div class="line">V. Lyzinski et al.</div>
<div class="line">Community Detection and Classification in Hierarchical Stochastic Blockmodels</div>
</div>
</li>
</ul>
</div></blockquote>
<p>The interface is as follows:</p>
<dl class="function">
<dt id="_CPPv214ApproximateASERK9GraphTypeiRNSt6vectorIN9GraphType11vertex_typeEEERN2El6MatrixI1TEERN4base9context_tE24approximate_ase_params_t">
<span id="ApproximateASE__GraphTypeCR.i.std::vector:GraphType::vertex_type:R.El::Matrix:T:R.base::context_tR.approximate_ase_params_t"></span>void <code class="descclassname"></code><code class="descname">ApproximateASE</code><span class="sig-paren">(</span><em class="property">const</em> GraphType &amp;<em>G</em>, int <em>k</em>, std::vector&lt;<em class="property">typename</em> GraphType::<a class="reference internal" href="#_CPPv2N9GraphType11vertex_typeE" title="GraphType::vertex_type">vertex_type</a>&gt; &amp;<em>indexmap</em>, El::Matrix&lt;T&gt; &amp;<em>X</em>, base::context_t &amp;<em>context</em>, approximate_ase_params_t <em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv214ApproximateASERK9GraphTypeiRNSt6vectorIN9GraphType11vertex_typeEEERN2El6MatrixI1TEERN4base9context_tE24approximate_ase_params_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>X will be filled with the embedding. Each row of X is associated with one vertex. indexmap is a map between row index
and the vertex. The parameter structure is similar to the one specified to approximate SVD.</p>
<p>The graph is specified using parameter G. The type is generic: the GraphType class is expected to
support the following:</p>
<dl class="type">
<dt id="_CPPv2N9GraphType11vertex_typeE">
<span id="GraphType::vertex_type"></span><em class="property">type </em><code class="descclassname">GraphType::</code><code class="descname">vertex_type</code><a class="headerlink" href="#_CPPv2N9GraphType11vertex_typeE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Type of the graph nodes</p>
<dl class="function">
<dt id="_CPPv2N9GraphType16adjacency_matrixERN4base15sparse_matrix_tI1TEERNSt6vectorI11vertex_typeEE">
<span id="GraphType::adjacency_matrix__base::sparse_matrix_t:T:R.std::vector:vertex_type:R"></span>size_t <code class="descclassname">GraphType::</code><code class="descname">adjacency_matrix</code><span class="sig-paren">(</span>base::sparse_matrix_t&lt;T&gt; &amp;<em>A</em>, std::vector&lt;<a class="reference internal" href="#_CPPv2N9GraphType11vertex_typeE" title="GraphType::vertex_type">vertex_type</a>&gt; &amp;<em>indexmap</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N9GraphType16adjacency_matrixERN4base15sparse_matrix_tI1TEERNSt6vectorI11vertex_typeEE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Fills the adjacency matrix of the graph</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently, approximate ASE is computed only on a single machine, and no MPI (OpenMP is used, but in a limited manner).
This will change in the future.</p>
</div>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="nla.html">Numerical Linear Algebra Primitives</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="io.html">IO in libSkylark</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright IBM Corporation 2012-2014.  All Rights Reserved.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.1.
    </div>
  </body>
</html>